// -----------------------------------------------------------------------------------------------------
// Copyright (c) 2006-2019, Knut Reinert & Freie Universität Berlin
// Copyright (c) 2016-2019, Knut Reinert & MPI für molekulare Genetik
// This file may be used, modified and/or redistributed under the terms of the 3-clause BSD-License
// shipped with this file and also available at: https://github.com/seqan/seqan3/blob/master/LICENSE.md
// -----------------------------------------------------------------------------------------------------

/*!\file
 * \brief Provides seqan3::search_result_range.
 * \author Rene Rahn <rene.rahn AT fu-berlin.de>
 */

#pragma once

#include <seqan3/std/concepts>
#include <seqan3/std/ranges>

#include <seqan3/core/algorithm/detail/algorithm_executor_blocking.hpp>
#include <seqan3/core/type_traits/template_inspection.hpp>

namespace seqan3
{

/*!\brief An input range over the search results generated by the given search algorithm.
 * \ingroup search
 * \implements std::ranges::input_range
 *
 * \tparam search_executor_t The type of the search algorithm executor; must be a type instantiation of
 *                           seqan3::detail::algorithm_executor_blocking
 *
 * \details
 *
 * Provides a lazy input-range interface over the search results generated by the underlying search executor.
 */
template <typename search_executor_t>
//!\cond
    requires detail::is_type_specialisation_of_v<search_executor_t, detail::algorithm_executor_blocking>
//!\endcond
class search_result_range
{
private:
    //!\brief The optional type returned by the seqan3::detail::algorithm_executor_blocking
    using optional_type = decltype(std::declval<search_executor_t &>().next_result());
    //!\brief The actual search result type.
    using search_result_type = typename optional_type::value_type;

    class search_result_range_iterator;

    //!\brief Befriend the iterator type.
    friend class search_result_range_iterator;

    //!\brief A pointer to the search executor.
    std::unique_ptr<search_executor_t> executor_ptr{nullptr};
    //!\brief Caches the last read search result.
    search_result_type cached_search_result{};

public:
    /*!\name Constructors, destructor and assignment
     * \{
     */
    search_result_range() = default; //!< Defaulted.
    search_result_range(search_result_range const &) = delete; //!< This is a move-only type.
    search_result_range(search_result_range &&) = default; //!< Defaulted.
    search_result_range & operator=(search_result_range const &) = delete; //!< This is a move-only type.
    search_result_range & operator=(search_result_range &&) = default; //!< Defaulted.
    ~search_result_range() = default; //!< Defaulted.

    /*!\brief Constructs a search result range.
     *
     * \param[in] search_executor The search executor that executes the search and provides the search result.
     */
    search_result_range(search_executor_t && search_executor) :
        executor_ptr{std::make_unique<search_executor_t>(std::move(search_executor))}
    {}
    //!\}

    /*!\name Iterators
     * \{
     */

    //!\brief Returns an iterator to the first element of the search result range.
    constexpr search_result_range_iterator begin()
    {
        return search_result_range_iterator{*this};
    }

    search_result_range_iterator begin() const = delete;
    search_result_range_iterator cbegin() const = delete;

    /*!\brief Returns a sentinel signaling the end of the search result range.
     * \return a sentinel.
     *
     * \details
     *
     * The search result range is an input range and the end is reached when all queries have been processed.
     */
    constexpr std::default_sentinel_t end() noexcept
    {
        return std::default_sentinel;
    }

    constexpr std::default_sentinel_t end() const = delete;
    constexpr std::default_sentinel_t cend() const = delete;
    //!\}

private:
    /*!\brief Receives the search results from the next query.
     *
     * \returns `true` if hits could be found for the current query, otherwise `false`.
     *
     * \details
     *
     * Invokes the search on the current query and increments the query iterator.
     */
    bool next()
    {
        if (!executor_ptr)
            throw std::runtime_error{"No search execution buffer available."};

        if (auto opt = executor_ptr->next_result(); opt.has_value())
        {
            cached_search_result = std::move(*opt);
            return true;
        }

        return false;
    }
};

/*!\brief The iterator of seqan3::detail::search_result_range.
 * \implements std::input_iterator
 */
template <typename search_executor_t>
//!\cond
    requires detail::is_type_specialisation_of_v<search_executor_t, detail::algorithm_executor_blocking>
//!\endcond
class search_result_range<search_executor_t>::search_result_range_iterator
{
private:
    //!\brief Pointer to the underlying range.
    search_result_range * range_ptr{};
    //!\brief Indicates the end of the underlying range.
    bool at_end{true};

public:
    /*!\name Associated types
     * \{
     */
    //!\brief Type for distances between iterators.
    using difference_type = std::ptrdiff_t;
    //!\brief Value type of container elements.
    using value_type = search_result_type;
    //!\brief Use reference type defined by container.
    using reference = std::add_lvalue_reference_t<value_type>;
    //!\brief Pointer type is pointer of container element type.
    using pointer = std::add_pointer_t<value_type>;
    //!\brief Sets iterator category as input iterator.
    using iterator_category = std::input_iterator_tag;
    //!\}

    /*!\name Constructors, destructor and assignment
     * \{
     */
    constexpr search_result_range_iterator() noexcept = default; //!< Defaulted.
    constexpr search_result_range_iterator(search_result_range_iterator const &) noexcept = default; //!< Defaulted.
    constexpr search_result_range_iterator(search_result_range_iterator &&) noexcept = default; //!< Defaulted.
    constexpr search_result_range_iterator & operator=(search_result_range_iterator const &) noexcept = default; //!< Defaulted.
    constexpr search_result_range_iterator & operator=(search_result_range_iterator &&) noexcept = default; //!< Defaulted.
    ~search_result_range_iterator() = default; //!< Defaulted.

    /*!\brief Construct from the associated search result range.
     *
     * \param[in] range The associated search result range.
     *
     * \details
     *
     * Initialises the iterator with the associated search result range.
     */
    explicit constexpr search_result_range_iterator(search_result_range & range) :
        range_ptr(std::addressof(range))
    {
        ++(*this); // Fetch the next element.
    }
    //!\}

    /*!\name Access operators
     * \{
     */

    //!\brief Returns the search result the `this` is pointing to.
    reference operator*() const noexcept
    {
        return range_ptr->cached_search_result;
    }

    //!\brief Returns a pointer to search result the `this` is pointing to.
    pointer operator->() const noexcept
    {
        return std::addressof(range_ptr->cached_search_result);
    }
    //!\}

    /*!\name Arithmetic operators
     * \{
     */
    //!\brief Increments the iterator by one.
    search_result_range_iterator & operator++(/*pre*/)
    {
        assert(range_ptr != nullptr);

        at_end = !range_ptr->next();
        return *this;
    }

    //!\brief Increments the iterator by one.
    void operator++(int /*post*/)
    {
        ++(*this);
    }
    //!\}

    /*!\name Comparison operators
     * \{
     */
    //!\brief Checks whether `lhs` is equal to the sentinel.
    friend constexpr bool operator==(search_result_range_iterator const & lhs,
                                     std::ranges::default_sentinel_t const &) noexcept
    {
        return lhs.at_end;
    }

    //!\brief Checks whether `lhs` is equal to `rhs`.
    friend constexpr bool operator==(std::ranges::default_sentinel_t const & lhs,
                                     search_result_range_iterator const & rhs) noexcept
    {
        return rhs == lhs;
    }

    //!\brief Checks whether `lhs` is not equal to the sentinel.
    friend constexpr bool operator!=(search_result_range_iterator const & lhs,
                                     std::ranges::default_sentinel_t const & rhs) noexcept
    {
        return !(lhs == rhs);
    }

    //!\brief Checks whether `lhs` is not equal to `rhs`.
    friend constexpr bool operator!=(std::ranges::default_sentinel_t const & lhs,
                                     search_result_range_iterator const & rhs) noexcept
    {
        return !(lhs == rhs);
    }
    //!\}
};

} // namespace seqan3
